{"ast":null,"code":"var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n/*\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nvar WeakMap = window.WeakMap;\n\nif (typeof WeakMap === 'undefined') {\n  var defineProperty = Object.defineProperty;\n  var counter = Date.now() % 1e9;\n\n  WeakMap = function WeakMap() {\n    this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n  };\n\n  WeakMap.prototype = {\n    set: function set(key, value) {\n      var entry = key[this.name];\n      if (entry && entry[0] === key) entry[1] = value;else defineProperty(key, this.name, {\n        value: [key, value],\n        writable: true\n      });\n      return this;\n    },\n    get: function get(key) {\n      var entry;\n      return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n    },\n    'delete': function _delete(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      var hasValue = entry[0] === key;\n      entry[0] = entry[1] = undefined;\n      return hasValue;\n    },\n    has: function has(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      return entry[0] === key;\n    }\n  };\n}\n\nvar registrationsTable = new WeakMap(); // We use setImmediate or postMessage for our future callback.\n\nvar setImmediate = window.msSetImmediate; // Use post message to emulate setImmediate.\n\nif (!setImmediate) {\n  var setImmediateQueue = [];\n  var sentinel = String(Math.random());\n  window.addEventListener('message', function (e) {\n    if (e.data === sentinel) {\n      var queue = setImmediateQueue;\n      setImmediateQueue = [];\n      queue.forEach(function (func) {\n        func();\n      });\n    }\n  });\n\n  setImmediate = function setImmediate(func) {\n    setImmediateQueue.push(func);\n    window.postMessage(sentinel, '*');\n  };\n} // This is used to ensure that we never schedule 2 callas to setImmediate\n\n\nvar isScheduled = false; // Keep track of observers that needs to be notified next time.\n\nvar scheduledObservers = [];\n/**\n * Schedules |dispatchCallback| to be called in the future.\n * @param {MutationObserver} observer\n */\n\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n\n  if (!isScheduled) {\n    isScheduled = true;\n    setImmediate(dispatchCallbacks);\n  }\n}\n\nfunction wrapIfNeeded(node) {\n  return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\n}\n\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  var observers = scheduledObservers;\n  scheduledObservers = []; // Sort observers based on their creation UID (incremental).\n\n  observers.sort(function (o1, o2) {\n    return o1.uid_ - o2.uid_;\n  });\n  var anyNonEmpty = false;\n  observers.forEach(function (observer) {\n    // 2.1, 2.2\n    var queue = observer.takeRecords(); // 2.3. Remove all transient registered observers whose observer is mo.\n\n    removeTransientObserversFor(observer); // 2.4\n\n    if (queue.length) {\n      observer.callback_(queue, observer);\n      anyNonEmpty = true;\n    }\n  }); // 3.\n\n  if (anyNonEmpty) dispatchCallbacks();\n}\n\nfunction removeTransientObserversFor(observer) {\n  observer.nodes_.forEach(function (node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations) return;\n    registrations.forEach(function (registration) {\n      if (registration.observer === observer) registration.removeTransientObservers();\n    });\n  });\n}\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\n\n\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options; // Only target ignores subtree.\n\n        if (node !== target && !options.subtree) continue;\n        var record = callback(options);\n        if (record) registration.enqueue(record);\n      }\n    }\n  }\n}\n\nvar uidCounter = 0;\n/**\n * The class that maps to the DOM MutationObserver interface.\n * @param {Function} callback.\n * @constructor\n */\n\nfunction JsMutationObserver(callback) {\n  this.callback_ = callback;\n  this.nodes_ = [];\n  this.records_ = [];\n  this.uid_ = ++uidCounter;\n}\n\nJsMutationObserver.prototype = {\n  observe: function observe(target, options) {\n    target = wrapIfNeeded(target); // 1.1\n\n    if (!options.childList && !options.attributes && !options.characterData || // 1.2\n    options.attributeOldValue && !options.attributes || // 1.3\n    options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4\n    options.characterDataOldValue && !options.characterData) {\n      throw new SyntaxError();\n    }\n\n    var registrations = registrationsTable.get(target);\n    if (!registrations) registrationsTable.set(target, registrations = []); // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n\n    var registration;\n\n    for (var i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    } // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n\n\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes_.push(target);\n    }\n\n    registration.addListeners();\n  },\n  disconnect: function disconnect() {\n    this.nodes_.forEach(function (node) {\n      var registrations = registrationsTable.get(node);\n\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n\n        if (registration.observer === this) {\n          registration.removeListeners();\n          registrations.splice(i, 1); // Each node can only have one registered observer associated with\n          // this observer.\n\n          break;\n        }\n      }\n    }, this);\n    this.records_ = [];\n  },\n  takeRecords: function takeRecords() {\n    var copyOfRecords = this.records_;\n    this.records_ = [];\n    return copyOfRecords;\n  }\n};\n/**\n * @param {string} type\n * @param {Node} target\n * @constructor\n */\n\nfunction MutationRecord(type, target) {\n  this.type = type;\n  this.target = target;\n  this.addedNodes = [];\n  this.removedNodes = [];\n  this.previousSibling = null;\n  this.nextSibling = null;\n  this.attributeName = null;\n  this.attributeNamespace = null;\n  this.oldValue = null;\n}\n\nfunction copyMutationRecord(original) {\n  var record = new MutationRecord(original.type, original.target);\n  record.addedNodes = original.addedNodes.slice();\n  record.removedNodes = original.removedNodes.slice();\n  record.previousSibling = original.previousSibling;\n  record.nextSibling = original.nextSibling;\n  record.attributeName = original.attributeName;\n  record.attributeNamespace = original.attributeNamespace;\n  record.oldValue = original.oldValue;\n  return record;\n}\n\n; // We keep track of the two (possibly one) records used in a single mutation.\n\nvar currentRecord, recordWithOldValue;\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n * @param {string} oldValue\n * @return {MutationRecord}\n */\n\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n * @param {string} oldValue\n * @return {MutationRecord}\n */\n\n\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue) return recordWithOldValue;\n  recordWithOldValue = copyMutationRecord(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n/**\n * @param {MutationRecord} record\n * @return {boolean} Whether the record represents a record from the current\n * mutation event.\n */\n\n\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n *\n * @param {MutationRecord} lastRecord\n * @param {MutationRecord} newRecord\n * @param {MutationRecord}\n */\n\n\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord) return lastRecord; // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n  return null;\n}\n/**\n * Class used to represent a registered observer.\n * @param {MutationObserver} observer\n * @param {Node} target\n * @param {MutationObserverInit} options\n * @constructor\n */\n\n\nfunction Registration(observer, target, options) {\n  this.observer = observer;\n  this.target = target;\n  this.options = options;\n  this.transientObservedNodes = [];\n}\n\nRegistration.prototype = {\n  enqueue: function enqueue(record) {\n    var records = this.observer.records_;\n    var length = records.length; // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n\n    if (records.length > 0) {\n      var lastRecord = records[length - 1];\n      var recordToReplaceLast = selectRecord(lastRecord, record);\n\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  },\n  addListeners: function addListeners() {\n    this.addListeners_(this.target);\n  },\n  addListeners_: function addListeners_(node) {\n    var options = this.options;\n    if (options.attributes) node.addEventListener('DOMAttrModified', this, true);\n    if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n    if (options.childList) node.addEventListener('DOMNodeInserted', this, true);\n    if (options.childList || options.subtree) node.addEventListener('DOMNodeRemoved', this, true);\n  },\n  removeListeners: function removeListeners() {\n    this.removeListeners_(this.target);\n  },\n  removeListeners_: function removeListeners_(node) {\n    var options = this.options;\n    if (options.attributes) node.removeEventListener('DOMAttrModified', this, true);\n    if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n    if (options.childList) node.removeEventListener('DOMNodeInserted', this, true);\n    if (options.childList || options.subtree) node.removeEventListener('DOMNodeRemoved', this, true);\n  },\n\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   * @param {Node} node\n   */\n  addTransientObserver: function addTransientObserver(node) {\n    // Don't add transient observers on the target itself. We already have all\n    // the required listeners set up on the target.\n    if (node === this.target) return;\n    this.addListeners_(node);\n    this.transientObservedNodes.push(node);\n    var registrations = registrationsTable.get(node);\n    if (!registrations) registrationsTable.set(node, registrations = []); // We know that registrations does not contain this because we already\n    // checked if node === this.target.\n\n    registrations.push(this);\n  },\n  removeTransientObservers: function removeTransientObservers() {\n    var transientObservedNodes = this.transientObservedNodes;\n    this.transientObservedNodes = [];\n    transientObservedNodes.forEach(function (node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n      var registrations = registrationsTable.get(node);\n\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1); // Each node can only have one registered observer associated with\n          // this observer.\n\n          break;\n        }\n      }\n    }, this);\n  },\n  handleEvent: function handleEvent(e) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n\n    switch (e.type) {\n      case 'DOMAttrModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target; // 1.\n\n        var record = new getRecord('attributes', target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace; // 2.\n\n        var oldValue = null;\n        if (!(typeof MutationEvent !== 'undefined' && e.attrChange === MutationEvent.ADDITION)) oldValue = e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 3.1, 4.2\n          if (!options.attributes) return; // 3.2, 4.3\n\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          } // 3.3, 4.4\n\n\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue); // 3.4, 4.5\n\n          return record;\n        });\n        break;\n\n      case 'DOMCharacterDataModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n        var target = e.target; // 1.\n\n        var record = getRecord('characterData', target); // 2.\n\n        var oldValue = e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 3.1, 4.2\n          if (!options.characterData) return; // 3.2, 4.3\n\n          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue); // 3.3, 4.4\n\n          return record;\n        });\n        break;\n\n      case 'DOMNodeRemoved':\n        this.addTransientObserver(e.target);\n      // Fall through.\n\n      case 'DOMNodeInserted':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        var target = e.relatedNode;\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n\n        if (e.type === 'DOMNodeInserted') {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling; // 1.\n\n        var record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 2.1, 3.2\n          if (!options.childList) return; // 2.2, 3.3\n\n          return record;\n        });\n    }\n\n    clearRecords();\n  }\n};\n\nif (!MutationObserver) {\n  MutationObserver = JsMutationObserver;\n}\n\nmodule.exports = MutationObserver;","map":{"version":3,"sources":["C:/projects/lab/lab_2.0/node_modules/mutation-observer/index.js"],"names":["MutationObserver","window","WebKitMutationObserver","MozMutationObserver","WeakMap","defineProperty","Object","counter","Date","now","name","Math","random","prototype","set","key","value","entry","writable","get","undefined","hasValue","has","registrationsTable","setImmediate","msSetImmediate","setImmediateQueue","sentinel","String","addEventListener","e","data","queue","forEach","func","push","postMessage","isScheduled","scheduledObservers","scheduleCallback","observer","dispatchCallbacks","wrapIfNeeded","node","ShadowDOMPolyfill","observers","sort","o1","o2","uid_","anyNonEmpty","takeRecords","removeTransientObserversFor","length","callback_","nodes_","registrations","registration","removeTransientObservers","forEachAncestorAndObserverEnqueueRecord","target","callback","parentNode","j","options","subtree","record","enqueue","uidCounter","JsMutationObserver","records_","observe","childList","attributes","characterData","attributeOldValue","attributeFilter","characterDataOldValue","SyntaxError","i","removeListeners","Registration","addListeners","disconnect","splice","copyOfRecords","MutationRecord","type","addedNodes","removedNodes","previousSibling","nextSibling","attributeName","attributeNamespace","oldValue","copyMutationRecord","original","slice","currentRecord","recordWithOldValue","getRecord","getRecordWithOldValue","clearRecords","recordRepresentsCurrentMutation","selectRecord","lastRecord","newRecord","transientObservedNodes","records","recordToReplaceLast","addListeners_","removeListeners_","removeEventListener","addTransientObserver","handleEvent","stopImmediatePropagation","attrName","namespace","relatedNode","namespaceURI","MutationEvent","attrChange","ADDITION","prevValue","indexOf","changedNode","module","exports"],"mappings":"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","sourcesContent":["var MutationObserver = window.MutationObserver\n  || window.WebKitMutationObserver\n  || window.MozMutationObserver;\n\n/*\n * Copyright 2012 The Polymer Authors. All rights reserved.\n * Use of this source code is goverened by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\nvar WeakMap = window.WeakMap;\n\nif (typeof WeakMap === 'undefined') {\n  var defineProperty = Object.defineProperty;\n  var counter = Date.now() % 1e9;\n\n  WeakMap = function() {\n    this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n  };\n\n  WeakMap.prototype = {\n    set: function(key, value) {\n      var entry = key[this.name];\n      if (entry && entry[0] === key)\n        entry[1] = value;\n      else\n        defineProperty(key, this.name, {value: [key, value], writable: true});\n      return this;\n    },\n    get: function(key) {\n      var entry;\n      return (entry = key[this.name]) && entry[0] === key ?\n          entry[1] : undefined;\n    },\n    'delete': function(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      var hasValue = entry[0] === key;\n      entry[0] = entry[1] = undefined;\n      return hasValue;\n    },\n    has: function(key) {\n      var entry = key[this.name];\n      if (!entry) return false;\n      return entry[0] === key;\n    }\n  };\n}\n\nvar registrationsTable = new WeakMap();\n\n// We use setImmediate or postMessage for our future callback.\nvar setImmediate = window.msSetImmediate;\n\n// Use post message to emulate setImmediate.\nif (!setImmediate) {\n  var setImmediateQueue = [];\n  var sentinel = String(Math.random());\n  window.addEventListener('message', function(e) {\n    if (e.data === sentinel) {\n      var queue = setImmediateQueue;\n      setImmediateQueue = [];\n      queue.forEach(function(func) {\n        func();\n      });\n    }\n  });\n  setImmediate = function(func) {\n    setImmediateQueue.push(func);\n    window.postMessage(sentinel, '*');\n  };\n}\n\n// This is used to ensure that we never schedule 2 callas to setImmediate\nvar isScheduled = false;\n\n// Keep track of observers that needs to be notified next time.\nvar scheduledObservers = [];\n\n/**\n * Schedules |dispatchCallback| to be called in the future.\n * @param {MutationObserver} observer\n */\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n  if (!isScheduled) {\n    isScheduled = true;\n    setImmediate(dispatchCallbacks);\n  }\n}\n\nfunction wrapIfNeeded(node) {\n  return window.ShadowDOMPolyfill &&\n      window.ShadowDOMPolyfill.wrapIfNeeded(node) ||\n      node;\n}\n\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  var observers = scheduledObservers;\n  scheduledObservers = [];\n  // Sort observers based on their creation UID (incremental).\n  observers.sort(function(o1, o2) {\n    return o1.uid_ - o2.uid_;\n  });\n\n  var anyNonEmpty = false;\n  observers.forEach(function(observer) {\n\n    // 2.1, 2.2\n    var queue = observer.takeRecords();\n    // 2.3. Remove all transient registered observers whose observer is mo.\n    removeTransientObserversFor(observer);\n\n    // 2.4\n    if (queue.length) {\n      observer.callback_(queue, observer);\n      anyNonEmpty = true;\n    }\n  });\n\n  // 3.\n  if (anyNonEmpty)\n    dispatchCallbacks();\n}\n\nfunction removeTransientObserversFor(observer) {\n  observer.nodes_.forEach(function(node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations)\n      return;\n    registrations.forEach(function(registration) {\n      if (registration.observer === observer)\n        registration.removeTransientObservers();\n    });\n  });\n}\n\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options;\n\n        // Only target ignores subtree.\n        if (node !== target && !options.subtree)\n          continue;\n\n        var record = callback(options);\n        if (record)\n          registration.enqueue(record);\n      }\n    }\n  }\n}\n\nvar uidCounter = 0;\n\n/**\n * The class that maps to the DOM MutationObserver interface.\n * @param {Function} callback.\n * @constructor\n */\nfunction JsMutationObserver(callback) {\n  this.callback_ = callback;\n  this.nodes_ = [];\n  this.records_ = [];\n  this.uid_ = ++uidCounter;\n}\n\nJsMutationObserver.prototype = {\n  observe: function(target, options) {\n    target = wrapIfNeeded(target);\n\n    // 1.1\n    if (!options.childList && !options.attributes && !options.characterData ||\n\n        // 1.2\n        options.attributeOldValue && !options.attributes ||\n\n        // 1.3\n        options.attributeFilter && options.attributeFilter.length &&\n            !options.attributes ||\n\n        // 1.4\n        options.characterDataOldValue && !options.characterData) {\n\n      throw new SyntaxError();\n    }\n\n    var registrations = registrationsTable.get(target);\n    if (!registrations)\n      registrationsTable.set(target, registrations = []);\n\n    // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n    var registration;\n    for (var i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    }\n\n    // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes_.push(target);\n    }\n\n    registration.addListeners();\n  },\n\n  disconnect: function() {\n    this.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n        if (registration.observer === this) {\n          registration.removeListeners();\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n    this.records_ = [];\n  },\n\n  takeRecords: function() {\n    var copyOfRecords = this.records_;\n    this.records_ = [];\n    return copyOfRecords;\n  }\n};\n\n/**\n * @param {string} type\n * @param {Node} target\n * @constructor\n */\nfunction MutationRecord(type, target) {\n  this.type = type;\n  this.target = target;\n  this.addedNodes = [];\n  this.removedNodes = [];\n  this.previousSibling = null;\n  this.nextSibling = null;\n  this.attributeName = null;\n  this.attributeNamespace = null;\n  this.oldValue = null;\n}\n\nfunction copyMutationRecord(original) {\n  var record = new MutationRecord(original.type, original.target);\n  record.addedNodes = original.addedNodes.slice();\n  record.removedNodes = original.removedNodes.slice();\n  record.previousSibling = original.previousSibling;\n  record.nextSibling = original.nextSibling;\n  record.attributeName = original.attributeName;\n  record.attributeNamespace = original.attributeNamespace;\n  record.oldValue = original.oldValue;\n  return record;\n};\n\n// We keep track of the two (possibly one) records used in a single mutation.\nvar currentRecord, recordWithOldValue;\n\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n * @param {string} oldValue\n * @return {MutationRecord}\n */\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n * @param {string} oldValue\n * @return {MutationRecord}\n */\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue)\n    return recordWithOldValue;\n  recordWithOldValue = copyMutationRecord(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n\n/**\n * @param {MutationRecord} record\n * @return {boolean} Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n *\n * @param {MutationRecord} lastRecord\n * @param {MutationRecord} newRecord\n * @param {MutationRecord}\n */\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord)\n    return lastRecord;\n\n  // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n    return recordWithOldValue;\n\n  return null;\n}\n\n/**\n * Class used to represent a registered observer.\n * @param {MutationObserver} observer\n * @param {Node} target\n * @param {MutationObserverInit} options\n * @constructor\n */\nfunction Registration(observer, target, options) {\n  this.observer = observer;\n  this.target = target;\n  this.options = options;\n  this.transientObservedNodes = [];\n}\n\nRegistration.prototype = {\n  enqueue: function(record) {\n    var records = this.observer.records_;\n    var length = records.length;\n\n    // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n    if (records.length > 0) {\n      var lastRecord = records[length - 1];\n      var recordToReplaceLast = selectRecord(lastRecord, record);\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  },\n\n  addListeners: function() {\n    this.addListeners_(this.target);\n  },\n\n  addListeners_: function(node) {\n    var options = this.options;\n    if (options.attributes)\n      node.addEventListener('DOMAttrModified', this, true);\n\n    if (options.characterData)\n      node.addEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.addEventListener('DOMNodeInserted', this, true);\n\n    if (options.childList || options.subtree)\n      node.addEventListener('DOMNodeRemoved', this, true);\n  },\n\n  removeListeners: function() {\n    this.removeListeners_(this.target);\n  },\n\n  removeListeners_: function(node) {\n    var options = this.options;\n    if (options.attributes)\n      node.removeEventListener('DOMAttrModified', this, true);\n\n    if (options.characterData)\n      node.removeEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.removeEventListener('DOMNodeInserted', this, true);\n\n    if (options.childList || options.subtree)\n      node.removeEventListener('DOMNodeRemoved', this, true);\n  },\n\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   * @param {Node} node\n   */\n  addTransientObserver: function(node) {\n    // Don't add transient observers on the target itself. We already have all\n    // the required listeners set up on the target.\n    if (node === this.target)\n      return;\n\n    this.addListeners_(node);\n    this.transientObservedNodes.push(node);\n    var registrations = registrationsTable.get(node);\n    if (!registrations)\n      registrationsTable.set(node, registrations = []);\n\n    // We know that registrations does not contain this because we already\n    // checked if node === this.target.\n    registrations.push(this);\n  },\n\n  removeTransientObservers: function() {\n    var transientObservedNodes = this.transientObservedNodes;\n    this.transientObservedNodes = [];\n\n    transientObservedNodes.forEach(function(node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n  },\n\n  handleEvent: function(e) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n\n    switch (e.type) {\n      case 'DOMAttrModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target;\n\n        // 1.\n        var record = new getRecord('attributes', target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n\n        // 2.\n        var oldValue = null;\n        if (!(typeof MutationEvent !== 'undefined' && e.attrChange === MutationEvent.ADDITION))\n          oldValue = e.prevValue;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 3.1, 4.2\n          if (!options.attributes)\n            return;\n\n          // 3.2, 4.3\n          if (options.attributeFilter && options.attributeFilter.length &&\n              options.attributeFilter.indexOf(name) === -1 &&\n              options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          }\n          // 3.3, 4.4\n          if (options.attributeOldValue)\n            return getRecordWithOldValue(oldValue);\n\n          // 3.4, 4.5\n          return record;\n        });\n\n        break;\n\n      case 'DOMCharacterDataModified':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n        var target = e.target;\n\n        // 1.\n        var record = getRecord('characterData', target);\n\n        // 2.\n        var oldValue = e.prevValue;\n\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 3.1, 4.2\n          if (!options.characterData)\n            return;\n\n          // 3.2, 4.3\n          if (options.characterDataOldValue)\n            return getRecordWithOldValue(oldValue);\n\n          // 3.3, 4.4\n          return record;\n        });\n\n        break;\n\n      case 'DOMNodeRemoved':\n        this.addTransientObserver(e.target);\n        // Fall through.\n      case 'DOMNodeInserted':\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        var target = e.relatedNode;\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n        if (e.type === 'DOMNodeInserted') {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n\n        // 1.\n        var record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          // 2.1, 3.2\n          if (!options.childList)\n            return;\n\n          // 2.2, 3.3\n          return record;\n        });\n\n    }\n\n    clearRecords();\n  }\n};\n\nif (!MutationObserver) {\n  MutationObserver = JsMutationObserver;\n}\n\nmodule.exports = MutationObserver;\n"]},"metadata":{},"sourceType":"script"}